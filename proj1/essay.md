### Essay


When undertaking new software development projects, inheriting poorly documented and structured legacy codebases can pose major challenges. Inadequate documentation regarding setup, configurations, dependencies, and intended functionality force developers to waste copious time deciphering complex code. This essay will detail the difficulties faced by the team working with a legacy codebase lacking sufficient documentation, testing, and up-to-date dependencies. It will then explore potential solutions and recommendations to improve the structure, legibility, and extensibility of the codebase.

One of the primary challenges we encountered when taking on the project was the lack of documentation regarding its functionality and setup procedures. Documentation for environment setup and running procedures was not present, and in one instance, critical information about the database type used was completely missing. The backend system frequently crashed without providing any useful error logs. To identify the database, we had to resort to identifying the port number from the logs to determine that MongoDB was the database in use. Another crucial aspect that was absent is the description of how the database was designed and how it was structured. This is significant because, to expand the project effectively, we must take into account all the assumptions made earlier and determine the most suitable way to modify the structure to align with our future objectives.

There was a lack of clarity regarding the usage of environment variables. These variables are critical to running the code and are often used to change the behavior of the code. This only came to light after a lot of debugging and reading through the code. Since the purpose of these variables was also not documented, it became tricky to figure out what are the acceptable values which could be passed. 

Another major issue was the reliance on dependencies that lacked long-term sustainability, in this instance, it relied on goodwill from Heroku. A project was using Heroku's free tier to host the project, but this option was discontinued in November 2022. Consequently, we were forced to abandon a project because this dependency required us to reconfigure the underlying infrastructure the code relied upon. This was a significant challenge, particularly because we had limited familiarity with the code's context.

When we tried to get the project running on the computer, we quickly realized that the project depended on many outdated and deprecated packages. These packages were no longer available to download, meaning that we had to update the dependencies to make them work with the latest version of the packages. Since this project was based on NodeJS, the package management is not very straightforward. There are dependencies on which our dependencies depend, resulting in a cascade of upgrades of the packages. We quickly lost sight of all the necessary changes because of the version changes. Because of this, we could no longer guarantee that the packages were working as intended, nor if the code was working as intended. This problem was especially exacerbated by the fact that the code base was written in Javascript. Javascript doesnâ€™t offer any error messages based on static code analysis. There were only two ways for us to discover if the code was working as intended. One was to run the project and run through every functionality while watching the logs hoping to not see any errors. The other was to depend on the test suite to check if everything worked as expected.

The project's test coverage currently stands at 35%. While running the test suite, we were unable to get any meaningful information about if the code was broken. The insufficient test coverage has made it challenging to verify that the codebase and its dependencies work as intended. Also, closed issues were missing associated tests, which could potentially lead to the bug resurfacing in the code. It's also worth noting that the project comprises two separate codebases, one for the front end and another for the back end. Because these two codebases are developed independently, there is currently no mechanism to verify their compatibility and prevent potential issues from arising.

The codebase was challenging to understand due to its structure, lack of comments, and complex syntax. Furthermore, critical documentation for functions was located separately from where the functions were defined, which compounded the difficulty of reading the code.

Learning from the issues we faced while implementing the project some possible improvements that can be adopted to improve the code quality and maintainability are discussed below.

The documentation should encompass step-by-step instructions for setting up and running the project, catering to individuals unfamiliar with coding. Additionally, it should include vital information about different configuration options available for running the application. Furthermore, an extensive documentation section should be dedicated to environment variables, delineating their possible values, and their impact on program behavior. This documentation should be supplemented with sample environment variable files to exemplify various configurations, such as those for local system or AWS hosting. 

Implementing Docker for creating downloadable builds of the application is helpful. This approach guarantees a consistent and dependency-free runtime environment. The use of the dockerfile also doubles as documentation for setting up the environment, also since environment information needs to be explicitly mentioned we can be assured that it will be constantly updated. 

Enhancements can be applied to the codebase to enhance its overall readability and maintainability. One approach is to incorporate more comments directly above functions, ensuring that as the codebase evolves, the descriptions evolve alongside it, keeping them up to date. Another helpful strategy involves utilizing external tools to generate documentation that reads functions and their accompanying comments, in turn creating comprehensive function and class documentation. Additionally, using descriptive variable and function names helps convey the intended purpose of the code, saving developers the effort of thoroughly analyzing the entire codebase. 

Enhancing the logging system to provide more meaningful error messages is another valuable step. This can significantly reduce debugging time when troubleshooting code issues. Combining these improvements with comprehensive test case documentation would create a user-friendly and highly maintainable codebase. To further improve code readability, reduce the number of imports, and eliminate unused, deprecated code. 

In conclusion, although the tools and technology stack may evolve, it is critical to establish a codebase that prioritizes ease of use and high maintainability. The presence of comprehensive documentation, testing, and comments can significantly enhance the accessibility for contributors. It is also good to cultivate a codebase that avoids dependency on paid software or the risk of vendor lock-in.
